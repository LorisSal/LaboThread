A partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractèreA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de traA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier et
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier ets que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier etA partir du thread principal, lancez un thread (sans paramètre) dont la tâche est de compter le 
nombre d’occurrences d’un mot (par exemple « printf » ou « cout ») dans un fichier texte 
qu’il ouvrira dans sa fonction. Le thread principal attendra la fin du thread et récupérera le 
résultat qu’il affichera.
Dans le but de mettre en évidence le parallélisme (à partir de l’étape 2) et le rôle du scheduler, 
on va délibérément ralentir l’exécution du thread. Pour cela, le thread, dans une boucle (i étant 
initialisé à 0),
1. ouvre le fichier,
2. se positionne sur le caractère de position i dans le fichier,
3. lit autant de caractères que nécessaire (ex : 6 si mot cible = « printf ») 
(attention à la fin de fichier !),
4. ferme le fichier,
5. teste si la chaîne lue correspond au mot cible et incrémente éventuellement un
compteur.
6. incrémente i de un, remonte dans la boucle et cela jusqu’à la fin du fichier.
De plus, à chaque fois qu’il ouvrira le fichier le thread affichera « * » sur le terminal.
Consigne : on demande de travailler avec les fichiers non bufferisés.
Etape 2
Idem mais vous devez lancer 4 threads (sans paramètre) en parallèle sur 4 fonctions 
différentes. Les différences sont les fichiers à analyser, les mots recherchés et le nombre de 
tabulations (voir juste après). Dans cette étape, les noms de fichier et
